/*!
 * Vueform Mask Plugin v1.0.1 (https://github.com/vueform/plugin-mask)
 * Copyright (c) 2024-present Adam Berecz <adam@vueform.com>
 * Licensed under the MIT License
 */

import{toRefs as e,ref as a,computed as l,onMounted as u,watch as t,nextTick as s}from"vue";var v=(v={},n=null)=>({apply:"TextElement",props:{mask:{required:!1,type:[String,Object,Array,Function]},unmask:{require:!1,type:Boolean,default:!1},allowIncomplete:{require:!1,type:Boolean,default:!1}},setup(o,r,i){const{mask:m,inputType:d,formatLoad:k,unmask:c,allowIncomplete:p}=e(o);if(!m.value)return i;const{nullValue:f,value:y,el$:h,path:b,form$:M,defaultValue:V,resetting:g,resetValidators:w,input:x}=i,A=a(null),E=a(y.value),I=a([]),$=a(!1),j=l((()=>"function"==typeof v?v(n):v)),L=l((()=>{let e="function"==typeof m.value?T(m.value):q(m.value);return j.value.definitions&&(e={...e,definitions:C({...j.value.definitions,...e.definitions})}),j.value.blocks&&(e={...e,blocks:C({...j.value.blocks,...e.blocks})}),e.definitions&&(e={...e,definitions:C(e.definitions)}),e.blocks&&(e={...e,blocks:C(e.blocks)}),e})),O=l({get:()=>E.value,set:e=>E.value=e}),q=e=>"string"==typeof e?{mask:B(e)}:e instanceof RegExp?{mask:e}:Array.isArray(e)?e.map(q):e&&"object"==typeof e?D(e):{mask:e},C=e=>Object.keys(e).reduce(((a,l)=>({...a,[l]:q(e[l])})),{}),D=e=>{let a={...e};return"number"===e.mask&&(a.mask=Number),"range"===e.mask&&(a.mask=n.MaskedRange),"enum"===e.mask&&(a.mask=n.MaskedEnum),"date"===e.mask&&(a.mask=Date),void 0!==e.placeholder&&(a.lazy=!a.placeholder),void 0===e.caseInsensitive||e.matchValue||(a.matchValue=F),e.dispatch&&(a.dispatch=(a,l)=>e.dispatch(a,l,h.value,M.value)),Array.isArray(e.mask)&&(a.mask=e.mask.map(q),a.dispatch||(e.mask.some((e=>e.startsWith))&&(a.dispatch=(e,a)=>{const l=(a.value+e).replace(/\D/g,"");return a.compiledMasks.find((e=>0===l.indexOf(e.startsWith)))}),e.element&&(a.dispatch=(a,l)=>{let u=M.value.el$(e.element)?.value;return l.compiledMasks.find((e=>e.when==u||!e.when))}))),e.blocks&&(a.blocks=Object.keys(e.blocks).reduce(((a,l)=>({...a,[l]:q(e.blocks[l])})),{})),a},T=e=>q(e(n)),B=e=>e.replace(/\\\\/g,"\\"),F=(e,a,l)=>n.MaskedEnum.DEFAULTS.matchValue(e.toLowerCase(),a.toLowerCase(),l),R=()=>"text"===d.value||(console.error(`Input mask only works with type="text" (found at: '${b.value}').`),!1),S=()=>{O.value=A.value.displayValue,p.value||A.value.masked.isComplete?y.value=c.value?A.value.masked.unmaskedValue:A.value.value:y.value=f.value},W=()=>{A.value&&A.value.destroy()},z=()=>{A.value&&W(),A.value=n(h.value.input,L.value),A.value.on("accept",(()=>{S()})),S(),I.value.map((e=>e())),L.value?.element&&I.value.push(t(l((()=>M.value.el$(L.value.element).value)),(()=>{$.value?$.value=!1:O.value=f.value,N()})))},N=()=>{s((()=>{z()}))};return u((()=>{R()&&z()})),t(d,(e=>{R()})),t(L,((e,a)=>{A.value&&z()}),{deep:!0}),{...i,Mask:A,destroyMask:W,initMask:z,syncMask:S,refreshMask:N,handleInput:()=>{},model:O,load:(e,a=!1)=>{$.value=!0,y.value=f.value;let l=a&&k.value?k.value(e,M.value):e;y.value=l,A.value&&(A.value[c.value?"unmaskedValue":"value"]=l)},update:e=>{$.value=!0,y.value=f.value,y.value=e,A.value&&(A.value[c.value?"unmaskedValue":"value"]=e)},clear:()=>{x.value.value="",O.value=f.value,y.value=f.value},reset:()=>{g.value=!0,x.value.value=V.value,O.value=V.value,y.value=V.value,w()}}}});export{v as default};
