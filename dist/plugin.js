/*!
 * Vueform Mask Plugin v1.0.2 (https://github.com/vueform/plugin-mask)
 * Copyright (c) 2024-present Adam Berecz <adam@vueform.com>
 * Licensed under the MIT License
 */

import{toRefs as e,ref as a,computed as l,onMounted as u,watch as t,nextTick as s}from"vue";var v=(v={},n=null)=>({apply:"TextElement",props:{mask:{required:!1,type:[String,Object,Array,Function]},unmask:{require:!1,type:Boolean,default:!1},allowIncomplete:{require:!1,type:Boolean,default:!1}},setup(o,i,r){const{mask:m,inputType:d,formatLoad:k,unmask:c,allowIncomplete:p}=e(o);if(!m.value)return r;const{nullValue:f,value:y,el$:h,path:b,form$:M,defaultValue:V,resetting:g,resetValidators:w,input:x}=r,A=a(null),E=a(y.value),I=a([]),O=a(!1),$=l((()=>"function"==typeof v?v(n):v)),j=l((()=>{let e="function"==typeof m.value?B(m.value):C(m.value);return $.value.definitions&&(e={...e,definitions:D({...$.value.definitions,...e.definitions})}),$.value.blocks&&(e={...e,blocks:D({...$.value.blocks,...e.blocks})}),e.definitions&&(e={...e,definitions:D(e.definitions)}),e.blocks&&(e={...e,blocks:D(e.blocks)}),e})),L=l({get:()=>E.value,set:e=>E.value=e}),q=l((()=>-1!==[void 0,null,""].indexOf(L.value))),C=e=>"string"==typeof e?{mask:F(e)}:e instanceof RegExp?{mask:e}:Array.isArray(e)?e.map(C):e&&"object"==typeof e?T(e):{mask:e},D=e=>Object.keys(e).reduce(((a,l)=>({...a,[l]:C(e[l])})),{}),T=e=>{let a={...e};return"number"===e.mask&&(a.mask=Number),"range"===e.mask&&(a.mask=n.MaskedRange),"enum"===e.mask&&(a.mask=n.MaskedEnum),"date"===e.mask&&(a.mask=Date),void 0!==e.placeholder&&(a.lazy=!a.placeholder),void 0===e.caseInsensitive||e.matchValue||(a.matchValue=R),e.dispatch&&(a.dispatch=(a,l)=>e.dispatch(a,l,h.value,M.value)),Array.isArray(e.mask)&&(a.mask=e.mask.map(C),a.dispatch||(e.mask.some((e=>e.startsWith))&&(a.dispatch=(e,a)=>{const l=(a.value+e).replace(/\D/g,"");return a.compiledMasks.find((e=>0===l.indexOf(e.startsWith)))}),e.element&&(a.dispatch=(a,l)=>{let u=M.value.el$(e.element)?.value;return l.compiledMasks.find((e=>e.when==u||!e.when))}))),e.blocks&&(a.blocks=Object.keys(e.blocks).reduce(((a,l)=>({...a,[l]:C(e.blocks[l])})),{})),a},B=e=>C(e(n)),F=e=>e.replace(/\\\\/g,"\\"),R=(e,a,l)=>n.MaskedEnum.DEFAULTS.matchValue(e.toLowerCase(),a.toLowerCase(),l),S=()=>"text"===d.value||(console.error(`Input mask only works with type="text" (found at: '${b.value}').`),!1),W=()=>{L.value=A.value.displayValue,p.value||A.value.masked.isComplete?y.value=c.value?A.value.masked.unmaskedValue:A.value.value:y.value=f.value},z=()=>{A.value&&A.value.destroy()},N=()=>{A.value&&z(),A.value=n(h.value.input,j.value),A.value.on("accept",(()=>{W()})),W(),I.value.map((e=>e())),j.value?.element&&I.value.push(t(l((()=>M.value.el$(j.value.element).value)),(()=>{O.value?O.value=!1:L.value=f.value,U()})))},U=()=>{s((()=>{N()}))};return u((()=>{S()&&N()})),t(d,(e=>{S()})),t(j,((e,a)=>{A.value&&N()}),{deep:!0}),{...r,Mask:A,destroyMask:z,initMask:N,syncMask:W,refreshMask:U,handleInput:()=>{},model:L,load:(e,a=!1)=>{O.value=!0,y.value=f.value;let l=a&&k.value?k.value(e,M.value):e;y.value=l,A.value&&(A.value[c.value?"unmaskedValue":"value"]=l)},update:e=>{O.value=!0,y.value=f.value,y.value=e,A.value&&(A.value[c.value?"unmaskedValue":"value"]=e)},clear:()=>{x.value.value="",L.value=f.value,y.value=f.value},reset:()=>{g.value=!0,x.value.value=V.value,L.value=V.value,y.value=V.value,w()},empty:q}}});export{v as default};
